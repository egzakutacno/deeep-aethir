{"version":3,"sources":["../src/hooks.ts"],"sourcesContent":["import type { HookContext } from '@deeep-network/riptide'\r\nimport { exec } from 'child_process'\r\nimport { spawn } from 'child_process'\r\nimport { promisify } from 'util'\r\n\r\nconst execAsync = promisify(exec)\r\n\r\nlet walletKeys: { privateKey?: string; publicKey?: string } = {}\r\n\r\nmodule.exports = {\r\n  installSecrets: async ({ env, logger }: HookContext) => {\r\n    logger.info('Checking Aethir checker configuration')\r\n    \r\n    // No specific secrets required for Aethir checker\r\n    // Wallet will be created during startup\r\n    return { success: true }\r\n  },\r\n\r\n  start: async ({ env, logger }: HookContext) => {\r\n    logger.info('Starting Aethir checker setup via systemd')\r\n    \r\n    try {\r\n      // Step 1: Accept terms and create wallet\r\n      await setupAethirWallet(logger)\r\n      \r\n      // Step 2: Start Aethir service via systemd\r\n      await startAethirService(logger)\r\n      \r\n      logger.info('Aethir checker started successfully via systemd')\r\n    } catch (error) {\r\n      logger.error(`Failed to start Aethir checker: ${error}`)\r\n      throw error\r\n    }\r\n  },\r\n\r\n  health: async ({ logger, utils }: HookContext) => {\r\n    logger.debug('Checking Aethir checker health via systemd')\r\n    \r\n    try {\r\n      const { stdout } = await execAsync('systemctl is-active aethir-checker')\r\n      return stdout.trim() === 'active'\r\n    } catch (error) {\r\n      logger.error(`Health check failed: ${error}`)\r\n      return false\r\n    }\r\n  },\r\n\r\n  heartbeat: async ({ logger }: HookContext) => {\r\n    logger.debug('Reporting Aethir checker status')\r\n    \r\n    return {\r\n      status: 'running',\r\n      walletKeys: walletKeys,\r\n      serviceStatus: await getServiceStatus()\r\n    }\r\n  },\r\n\r\n  stop: async ({ logger, utils }: HookContext) => {\r\n    logger.info('Stopping Aethir checker via systemd')\r\n    \r\n    try {\r\n      await execAsync('systemctl stop aethir-checker')\r\n      logger.info('Aethir checker stopped via systemd')\r\n    } catch (error) {\r\n      logger.error(`Failed to stop Aethir checker: ${error}`)\r\n    }\r\n  }\r\n}\r\n\r\nasync function setupAethirWallet(logger: any): Promise<void> {\r\n  logger.info('Setting up Aethir wallet...')\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    let outputBuffer = ''\r\n    let state: 'waiting_for_terms' | 'waiting_for_prompt' | 'waiting_for_keys' | 'done' = 'waiting_for_terms'\r\n    \r\n    // Spawn the Aethir CLI process\r\n    const aethirProcess = spawn('./AethirCheckerCLI', {\r\n      cwd: '/opt/aethir-checker',\r\n      stdio: ['pipe', 'pipe', 'pipe']\r\n    })\r\n    \r\n    // Handle stdout line by line\r\n    aethirProcess.stdout.on('data', (data: Buffer) => {\r\n      const chunk = data.toString()\r\n      outputBuffer += chunk\r\n      \r\n      // Log all output for debugging\r\n      logger.info(`[AETHIR SETUP] ${chunk.trim()}`)\r\n      \r\n      // Process line by line\r\n      const lines = outputBuffer.split('\\n')\r\n      outputBuffer = lines.pop() || '' // Keep incomplete line in buffer\r\n      \r\n      for (const line of lines) {\r\n        const trimmedLine = line.trim()\r\n        \r\n        // State machine for handling prompts\r\n        switch (state) {\r\n          case 'waiting_for_terms':\r\n            if (trimmedLine.includes('Y/N:')) {\r\n              logger.info('Terms prompt detected, sending \"y\"')\r\n              aethirProcess.stdin.write('y\\n')\r\n              state = 'waiting_for_prompt'\r\n            }\r\n            break\r\n            \r\n          case 'waiting_for_prompt':\r\n            if (trimmedLine.includes('Aethir>')) {\r\n              logger.info('Aethir prompt detected, sending wallet create command')\r\n              aethirProcess.stdin.write('aethir wallet create\\n')\r\n              state = 'waiting_for_keys'\r\n            }\r\n            break\r\n            \r\n          case 'waiting_for_keys':\r\n            // Look for wallet keys in the output\r\n            const privateKeyMatch = trimmedLine.match(/Current private key:\\s*(.+)/)\r\n            const publicKeyMatch = trimmedLine.match(/Current public key:\\s*(.+)/)\r\n            \r\n            if (privateKeyMatch) {\r\n              walletKeys.privateKey = privateKeyMatch[1].trim()\r\n              logger.info('Private key extracted')\r\n            }\r\n            \r\n            if (publicKeyMatch) {\r\n              walletKeys.publicKey = publicKeyMatch[1].trim()\r\n              logger.info('Public key extracted')\r\n            }\r\n            \r\n            // Check if we have both keys\r\n            if (walletKeys.privateKey && walletKeys.publicKey) {\r\n              logger.info('Wallet keys extracted successfully')\r\n              state = 'done'\r\n              aethirProcess.kill('SIGTERM')\r\n            }\r\n            break\r\n        }\r\n      }\r\n    })\r\n    \r\n    // Handle stderr\r\n    aethirProcess.stderr.on('data', (data: Buffer) => {\r\n      logger.error(`[AETHIR ERROR] ${data.toString()}`)\r\n    })\r\n    \r\n    // Handle process exit\r\n    aethirProcess.on('close', (code: number) => {\r\n      if (state === 'done' && walletKeys.privateKey && walletKeys.publicKey) {\r\n        logger.info('Aethir setup completed successfully')\r\n        resolve()\r\n      } else {\r\n        logger.error(`Aethir process exited with code ${code}`)\r\n        reject(new Error(`Aethir setup failed with exit code ${code}`))\r\n      }\r\n    })\r\n    \r\n    // Handle process errors\r\n    aethirProcess.on('error', (error: Error) => {\r\n      logger.error(`Aethir process error: ${error.message}`)\r\n      reject(error)\r\n    })\r\n    \r\n    // Set timeout to prevent hanging\r\n    setTimeout(() => {\r\n      if (state !== 'done') {\r\n        logger.error('Aethir setup timed out')\r\n        aethirProcess.kill('SIGTERM')\r\n        reject(new Error('Aethir setup timed out'))\r\n      }\r\n    }, 30000) // 30 second timeout\r\n  })\r\n}\r\n\r\nasync function startAethirService(logger: any): Promise<void> {\r\n  logger.info('Starting Aethir checker service via systemd...')\r\n  \r\n  try {\r\n    await execAsync('systemctl start aethir-checker')\r\n    logger.info('Aethir service started via systemd')\r\n  } catch (error) {\r\n    logger.error(`Failed to start Aethir service: ${error}`)\r\n    throw error\r\n  }\r\n}\r\n\r\nasync function getServiceStatus(): Promise<string> {\r\n  try {\r\n    const { stdout } = await execAsync('systemctl is-active aethir-checker')\r\n    return stdout.trim()\r\n  } catch {\r\n    return 'inactive'\r\n  }\r\n}\r\n"],"mappings":"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","names":["import_child_process"]}