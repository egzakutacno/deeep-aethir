{"version":3,"sources":["../src/hooks.ts"],"sourcesContent":["import type { HookContext } from '@deeep-network/riptide'\r\nimport { exec } from 'child_process'\r\nimport { spawn } from 'child_process'\r\nimport { promisify } from 'util'\r\n\r\nconst execAsync = promisify(exec)\r\n\r\nlet walletKeys: { privateKey?: string; publicKey?: string } = {}\r\n\r\nmodule.exports = {\r\n  installSecrets: async ({ env, logger }: HookContext) => {\r\n    logger.info('Checking Aethir checker configuration')\r\n    \r\n    // No specific secrets required for Aethir checker\r\n    // Wallet will be created during startup\r\n    return { success: true }\r\n  },\r\n\r\n  start: async ({ env, logger }: HookContext) => {\r\n    logger.info('Starting Aethir checker setup via systemd')\r\n    \r\n    try {\r\n      // Step 1: Run install.sh to properly set up the Aethir service\r\n      logger.info('Running Aethir install.sh script...')\r\n      await execAsync('cd /opt/aethir-checker && ./install.sh')\r\n      logger.info('Aethir service installed and started')\r\n      \r\n      // Step 2: Create wallet via CLI (install.sh doesn't handle this)\r\n      logger.info('Creating wallet via Aethir CLI...')\r\n      await setupAethirWallet(logger)\r\n      \r\n      // Step 3: Restart Aethir service so it can find the wallet\r\n      logger.info('Restarting Aethir service to load wallet...')\r\n      await execAsync('systemctl restart aethir-checker')\r\n      \r\n      logger.info('Aethir checker started successfully')\r\n    } catch (error) {\r\n      logger.error(`Failed to start Aethir checker: ${error}`)\r\n      throw error\r\n    }\r\n  },\r\n\r\n  health: async ({ logger, utils }: HookContext) => {\r\n    logger.debug('Checking Aethir checker health via systemd')\r\n    \r\n    try {\r\n      const { stdout } = await execAsync('systemctl is-active aethir-checker')\r\n      return stdout.trim() === 'active'\r\n    } catch (error) {\r\n      logger.error(`Health check failed: ${error}`)\r\n      return false\r\n    }\r\n  },\r\n\r\n  heartbeat: async ({ logger }: HookContext) => {\r\n    logger.debug('Reporting Aethir checker status and managing licenses')\r\n    \r\n    try {\r\n      // Get current wallet keys\r\n      const currentKeys = await getCurrentWalletKeys(logger)\r\n      \r\n      // Get license summary\r\n      const licenseSummary = await getLicenseSummary(logger)\r\n      \r\n      // Auto-approve pending licenses if any\r\n      if (licenseSummary.pending > 0) {\r\n        logger.info(`Found ${licenseSummary.pending} pending licenses, auto-approving`)\r\n        await approveAllLicenses(logger)\r\n        \r\n        // Re-check summary after approval\r\n        const updatedSummary = await getLicenseSummary(logger)\r\n        logger.info(`License approval completed. New status: ${updatedSummary.ready} ready, ${updatedSummary.pending} pending`)\r\n      }\r\n      \r\n      return {\r\n        status: 'running',\r\n        walletKeys: currentKeys,\r\n        licenseSummary: licenseSummary,\r\n        serviceStatus: await getServiceStatus()\r\n      }\r\n    } catch (error) {\r\n      logger.error(`Heartbeat failed: ${error}`)\r\n      return {\r\n        status: 'error',\r\n        error: error instanceof Error ? error.message : String(error),\r\n        serviceStatus: await getServiceStatus()\r\n      }\r\n    }\r\n  },\r\n\r\n  stop: async ({ logger, utils }: HookContext) => {\r\n    logger.info('Stopping Aethir checker via systemd')\r\n    \r\n    try {\r\n      await execAsync('systemctl stop aethir-checker')\r\n      logger.info('Aethir checker stopped via systemd')\r\n    } catch (error) {\r\n      logger.error(`Failed to stop Aethir checker: ${error}`)\r\n    }\r\n  }\r\n}\r\n\r\nasync function setupAethirWallet(logger: any): Promise<void> {\r\n  logger.info('Setting up Aethir wallet...')\r\n  \r\n  // Stop Aethir service and kill CLI processes first to avoid conflicts\r\n  try {\r\n    logger.info('Attempting to stop Aethir service...')\r\n    await execAsync('systemctl stop aethir-checker 2>/dev/null || true')\r\n    logger.info('Stopped Aethir service before wallet setup')\r\n    \r\n    logger.info('Attempting to kill existing CLI processes...')\r\n    await execAsync('ps aux | grep AethirCheckerCLI | grep -v grep | awk \\'{print $2}\\' | xargs kill -9 2>/dev/null || true')\r\n    logger.info('Killed existing CLI processes')\r\n  } catch (error) {\r\n    logger.info('Aethir service/processes were not running or already stopped')\r\n  }\r\n  \r\n  logger.info('About to spawn Aethir CLI process...')\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    let outputBuffer = ''\r\n    let state: 'waiting_for_terms' | 'waiting_for_wallet_message' | 'waiting_for_prompt' | 'waiting_for_keys' | 'waiting_for_exit' | 'done' = 'waiting_for_terms'\r\n    \r\n    // Spawn the Aethir CLI process\r\n    const aethirProcess = spawn('./AethirCheckerCLI', {\r\n      cwd: '/opt/aethir-checker',\r\n      stdio: ['pipe', 'pipe', 'pipe'],\r\n      timeout: 60000 // 60 second timeout\r\n    })\r\n    \r\n    // Handle stdout line by line\r\n    aethirProcess.stdout.on('data', (data: Buffer) => {\r\n      const chunk = data.toString()\r\n      outputBuffer += chunk\r\n      \r\n      // Log all output for debugging (verbose)\r\n      logger.info(`[AETHIR SETUP RAW] ${chunk}`)\r\n      \r\n      // Process line by line\r\n      const lines = outputBuffer.split('\\n')\r\n      outputBuffer = lines.pop() || '' // Keep incomplete line in buffer\r\n      \r\n      for (const line of lines) {\r\n        const trimmedLine = line.trim()\r\n        \r\n        // State machine for handling prompts\r\n        switch (state) {\r\n          case 'waiting_for_terms':\r\n            if (trimmedLine.includes('Press y to continue') || trimmedLine.includes('Y/N:')) {\r\n              logger.info('Terms prompt detected, sending \"y\"')\r\n              // Wait a moment before sending input\r\n              setTimeout(() => {\r\n                aethirProcess.stdin.write('y\\n')\r\n                state = 'waiting_for_prompt'  // Go directly to waiting for Aethir prompt\r\n              }, 500)\r\n            } else if (trimmedLine.includes('Please create a wallet')) {\r\n              logger.info('Wallet message detected (terms already accepted), waiting for Aethir prompt')\r\n              state = 'waiting_for_prompt'\r\n            }\r\n            break\r\n            \r\n          case 'waiting_for_wallet_message':\r\n            logger.info(`Waiting for wallet message, current line: \"${trimmedLine}\"`)\r\n            if (trimmedLine.includes('Please create a wallet')) {\r\n              logger.info('Wallet creation message detected, waiting for Aethir prompt')\r\n              state = 'waiting_for_prompt'\r\n            } else if (trimmedLine === '') {\r\n              logger.info('Empty line received, continuing to wait for wallet message')\r\n            } else {\r\n              logger.info(`Other line in waiting_for_wallet_message state: \"${trimmedLine}\"`)\r\n            }\r\n            break\r\n            \r\n          case 'waiting_for_prompt':\r\n            logger.info(`Waiting for prompt, current line: \"${trimmedLine}\"`)\r\n            if (trimmedLine.includes('Aethir>')) {\r\n              logger.info('Aethir prompt detected, sending wallet create command')\r\n              aethirProcess.stdin.write('aethir wallet create\\n')\r\n              state = 'waiting_for_keys'\r\n            } else if (trimmedLine.includes('Please create a wallet')) {\r\n              logger.info('Wallet creation message detected, waiting for Aethir prompt')\r\n            } else if (trimmedLine === '') {\r\n              logger.info('Empty line received, continuing to wait')\r\n            } else {\r\n              logger.info(`Unknown line in waiting_for_prompt state: \"${trimmedLine}\"`)\r\n            }\r\n            break\r\n            \r\n          case 'waiting_for_keys':\r\n            // Look for wallet keys in the output\r\n            const privateKeyMatch = trimmedLine.match(/Current private key:\\s*$/)\r\n            const publicKeyMatch = trimmedLine.match(/Current public key:\\s*$/)\r\n            \r\n            if (privateKeyMatch) {\r\n              // Private key label detected, start collecting\r\n              walletKeys.privateKey = ''\r\n              logger.info('Private key start detected')\r\n            } else if (walletKeys.privateKey !== undefined && !walletKeys.publicKey && trimmedLine.match(/^[A-Za-z0-9+/=\\s-]+$/)) {\r\n              // Collect private key lines (base64 content)\r\n              walletKeys.privateKey += trimmedLine\r\n              logger.info('Collecting private key line')\r\n            }\r\n            \r\n            if (publicKeyMatch) {\r\n              // Public key label detected, next line will be the key\r\n              logger.info('Public key label detected')\r\n            } else if (walletKeys.privateKey && !walletKeys.publicKey && trimmedLine.match(/^[a-f0-9]{40}$/)) {\r\n              // Public key appears on the line after \"Current public key:\" (40 hex chars)\r\n              walletKeys.publicKey = trimmedLine.trim()\r\n              logger.info('Public key extracted: ' + walletKeys.publicKey)\r\n            }\r\n            \r\n            // Check for completion signal - \"No licenses delegated\" means setup is complete\r\n            if (trimmedLine.includes('No licenses delegated to your burner wallet')) {\r\n              logger.info('Aethir setup completed - wallet ready')\r\n              if (!walletKeys.publicKey && walletKeys.privateKey) {\r\n                // Extract public key from the previous line if not captured yet\r\n                const lines = outputBuffer.split('\\n')\r\n                for (let i = lines.length - 1; i >= 0; i--) {\r\n                  const pubKeyMatch = lines[i].trim().match(/Current public key:\\s*(.+)/)\r\n                  if (pubKeyMatch) {\r\n                    walletKeys.publicKey = pubKeyMatch[1].trim()\r\n                    logger.info('Public key extracted from previous line')\r\n                    break\r\n                  }\r\n                }\r\n              }\r\n              logger.info(`Wallet keys - Private: ${walletKeys.privateKey ? 'found' : 'missing'}, Public: ${walletKeys.publicKey ? 'found' : 'missing'}`)\r\n              \r\n              // Send exit command to properly close the CLI and save wallet files\r\n              logger.info('Sending exit command to save wallet files')\r\n              aethirProcess.stdin.write('aethir exit\\n')\r\n              state = 'waiting_for_exit'\r\n            }\r\n            \r\n            // Wait for the CLI to exit cleanly\r\n            if (state === 'waiting_for_exit' && trimmedLine.includes('Wait a moment, the client is exiting')) {\r\n              logger.info('Aethir CLI exiting cleanly, wallet files saved')\r\n              state = 'done'\r\n              // Let the process exit naturally instead of killing it\r\n            }\r\n            \r\n            // Check if we have both keys (fallback)\r\n            if (walletKeys.privateKey && walletKeys.publicKey) {\r\n              logger.info('Wallet keys extracted successfully')\r\n              logger.info(`Private key length: ${walletKeys.privateKey.length}`)\r\n              logger.info(`Public key: ${walletKeys.publicKey}`)\r\n              state = 'done'\r\n              aethirProcess.kill('SIGTERM')\r\n            }\r\n            break\r\n        }\r\n      }\r\n    })\r\n    \r\n    // Handle stderr\r\n    aethirProcess.stderr.on('data', (data: Buffer) => {\r\n      logger.error(`[AETHIR ERROR] ${data.toString()}`)\r\n    })\r\n    \r\n    // Handle process events (verbose)\r\n    aethirProcess.on('spawn', () => {\r\n      logger.info('[AETHIR PROCESS] Process spawned successfully')\r\n    })\r\n    \r\n    aethirProcess.on('error', (error: Error) => {\r\n      logger.error(`[AETHIR PROCESS ERROR] ${error.message}`)\r\n      reject(error)\r\n    })\r\n    \r\n    // Handle process exit\r\n    aethirProcess.on('close', (code: number) => {\r\n      logger.info(`[AETHIR PROCESS] Process exited with code ${code}, state: ${state}`)\r\n      if (state === 'done' && walletKeys.privateKey && walletKeys.publicKey) {\r\n        logger.info('Aethir setup completed successfully')\r\n        resolve()\r\n      } else {\r\n        logger.error(`Aethir process exited with code ${code}`)\r\n        reject(new Error(`Aethir setup failed with exit code ${code}`))\r\n      }\r\n    })\r\n    \r\n    // Set timeout to prevent hanging\r\n    setTimeout(() => {\r\n      if (state !== 'done') {\r\n        logger.error('Aethir setup timed out')\r\n        aethirProcess.kill('SIGTERM')\r\n        reject(new Error('Aethir setup timed out'))\r\n      }\r\n    }, 30000) // 30 second timeout\r\n  })\r\n}\r\n\r\nasync function startAethirService(logger: any): Promise<void> {\r\n  logger.info('Starting Aethir checker service via systemd...')\r\n  \r\n  try {\r\n    await execAsync('systemctl start aethir-checker')\r\n    logger.info('Aethir service started via systemd')\r\n  } catch (error) {\r\n    logger.error(`Failed to start Aethir service: ${error}`)\r\n    throw error\r\n  }\r\n}\r\n\r\nasync function getServiceStatus(): Promise<string> {\r\n  try {\r\n    const { stdout } = await execAsync('systemctl is-active aethir-checker')\r\n    return stdout.trim()\r\n  } catch {\r\n    return 'inactive'\r\n  }\r\n}\r\n\r\nasync function getCurrentWalletKeys(logger: any): Promise<{ privateKey?: string; publicKey?: string }> {\r\n  return new Promise((resolve) => {\r\n    let outputBuffer = ''\r\n    let keysFound = false\r\n    \r\n    // Kill any existing CLI processes first\r\n    execAsync('ps aux | grep AethirCheckerCLI | grep -v grep | awk \\'{print $2}\\' | xargs kill -9 2>/dev/null || true').then(() => {\r\n      // Wait a moment for process to fully terminate\r\n      setTimeout(() => {\r\n        const aethirProcess = spawn('bash', ['-c', 'cd /opt/aethir-checker && echo \"aethir wallet export\" | timeout 10 ./AethirCheckerCLI'], {\r\n          stdio: ['pipe', 'pipe', 'pipe']\r\n        })\r\n        \r\n        aethirProcess.stdout?.on('data', (data: Buffer) => {\r\n          outputBuffer += data.toString()\r\n          \r\n          // Look for wallet keys in the output (keys are on separate lines)\r\n          const privateKeyMatch = outputBuffer.match(/Current private key:\\s*\\n([^\\n]+)/)\r\n          const publicKeyMatch = outputBuffer.match(/Current public key:\\s*\\n([^\\n]+)/)\r\n          \r\n          if (privateKeyMatch && publicKeyMatch && !keysFound) {\r\n            keysFound = true\r\n            logger.info('Wallet keys found, sending exit command')\r\n            \r\n            // Send exit command to cleanly close the CLI\r\n            aethirProcess.stdin.write('aethir exit\\n')\r\n            \r\n            // Wait a moment for exit to complete, then resolve\r\n            setTimeout(() => {\r\n              aethirProcess.kill('SIGTERM')\r\n              resolve({\r\n                privateKey: privateKeyMatch[1].trim(),\r\n                publicKey: publicKeyMatch[1].trim()\r\n              })\r\n            }, 1000)\r\n          }\r\n        })\r\n        \r\n        aethirProcess.on('close', () => {\r\n          if (!keysFound) {\r\n            logger.warn('Could not extract wallet keys from export')\r\n            resolve({})\r\n          }\r\n        })\r\n        \r\n        aethirProcess.on('error', (error: Error) => {\r\n          logger.error(`Failed to get wallet keys: ${error}`)\r\n          resolve({})\r\n        })\r\n      }, 500) // Wait 500ms after killing processes\r\n    }).catch((error) => {\r\n      logger.error(`Failed to kill existing processes: ${error}`)\r\n      resolve({})\r\n    })\r\n  })\r\n}\r\n\r\nasync function getLicenseSummary(logger: any): Promise<{\r\n  checking: number;\r\n  ready: number;\r\n  offline: number;\r\n  banned: number;\r\n  pending: number;\r\n  totalDelegated: number;\r\n}> {\r\n  return new Promise((resolve) => {\r\n    let outputBuffer = ''\r\n    let summaryFound = false\r\n    \r\n    const aethirProcess = spawn('bash', ['-c', 'cd /opt/aethir-checker && echo \"aethir license summary\" | timeout 10 ./AethirCheckerCLI'], {\r\n      stdio: ['pipe', 'pipe', 'pipe']\r\n    })\r\n    \r\n    aethirProcess.stdout?.on('data', (data: Buffer) => {\r\n      outputBuffer += data.toString()\r\n      \r\n      // Look for license summary table\r\n      if (outputBuffer.includes('Number') && outputBuffer.includes('Status') && outputBuffer.includes('Total Delegated') && !summaryFound) {\r\n        summaryFound = true\r\n        \r\n        // Parse license summary output\r\n        const checkingMatch = outputBuffer.match(/(\\d+)\\s+Checking/)\r\n        const readyMatch = outputBuffer.match(/(\\d+)\\s+Ready/)\r\n        const offlineMatch = outputBuffer.match(/(\\d+)\\s+Offline/)\r\n        const bannedMatch = outputBuffer.match(/(\\d+)\\s+Banned/)\r\n        const pendingMatch = outputBuffer.match(/(\\d+)\\s+Pending/)\r\n        const totalMatch = outputBuffer.match(/(\\d+)\\s+Total Delegated/)\r\n        \r\n        aethirProcess.kill('SIGTERM')\r\n        resolve({\r\n          checking: checkingMatch ? parseInt(checkingMatch[1]) : 0,\r\n          ready: readyMatch ? parseInt(readyMatch[1]) : 0,\r\n          offline: offlineMatch ? parseInt(offlineMatch[1]) : 0,\r\n          banned: bannedMatch ? parseInt(bannedMatch[1]) : 0,\r\n          pending: pendingMatch ? parseInt(pendingMatch[1]) : 0,\r\n          totalDelegated: totalMatch ? parseInt(totalMatch[1]) : 0\r\n        })\r\n      }\r\n    })\r\n    \r\n    aethirProcess.on('close', () => {\r\n      if (!summaryFound) {\r\n        logger.error('Failed to get license summary - table not found')\r\n        resolve({\r\n          checking: 0,\r\n          ready: 0,\r\n          offline: 0,\r\n          banned: 0,\r\n          pending: 0,\r\n          totalDelegated: 0\r\n        })\r\n      }\r\n    })\r\n    \r\n    aethirProcess.on('error', (error: Error) => {\r\n      logger.error(`Failed to get license summary: ${error}`)\r\n      resolve({\r\n        checking: 0,\r\n        ready: 0,\r\n        offline: 0,\r\n        banned: 0,\r\n        pending: 0,\r\n        totalDelegated: 0\r\n      })\r\n    })\r\n  })\r\n}\r\n\r\nasync function approveAllLicenses(logger: any): Promise<void> {\r\n  return new Promise((resolve, reject) => {\r\n    let outputBuffer = ''\r\n    let approvalFound = false\r\n    \r\n    const aethirProcess = spawn('bash', ['-c', 'cd /opt/aethir-checker && echo \"aethir license approve --all\" | timeout 10 ./AethirCheckerCLI'], {\r\n      stdio: ['pipe', 'pipe', 'pipe']\r\n    })\r\n    \r\n    aethirProcess.stdout?.on('data', (data: Buffer) => {\r\n      outputBuffer += data.toString()\r\n      \r\n      // Look for approval success message\r\n      if (outputBuffer.includes('License operation approve success') && !approvalFound) {\r\n        approvalFound = true\r\n        logger.info('License approval successful')\r\n        aethirProcess.kill('SIGTERM')\r\n        resolve()\r\n      }\r\n    })\r\n    \r\n    aethirProcess.on('close', () => {\r\n      if (!approvalFound) {\r\n        logger.warn('License approval may not have succeeded')\r\n        resolve() // Don't reject, just warn\r\n      }\r\n    })\r\n    \r\n    aethirProcess.on('error', (error: Error) => {\r\n      logger.error(`Failed to approve licenses: ${error}`)\r\n      reject(error)\r\n    })\r\n  })\r\n}\r\n"],"mappings":"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","names":["import_child_process","lines"]}